This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-11T01:52:27.391Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  index.ts
  tools.ts
  twitterClient.ts
  types.ts
.env.example
.gitignore
LICENSE
package.json
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: src/index.ts
================
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { ListToolsRequestSchema, CallToolRequestSchema } from '@modelcontextprotocol/sdk/types.js';
import { getTwitterClient } from './twitterClient.js';
import { 
    assertPostTweetArgs, 
    assertSearchTweetsArgs, 
    assertReplyToTweetArgs, 
    assertGetUserTimelineArgs, 
    assertGetTweetByIdArgs, 
    assertGetUserInfoArgs, 
    assertGetTweetsByIdsArgs, 
    assertPostTweetWithMediaArgs,
    assertLikeTweetArgs,
    assertUnlikeTweetArgs,
    assertGetLikedTweetsArgs,
    assertRetweetArgs,
    assertUndoRetweetArgs,
    assertGetRetweetsArgs,
    assertFollowUserArgs,
    assertUnfollowUserArgs,
    assertGetFollowersArgs,
    assertGetFollowingArgs,
    assertCreateListArgs,
    assertAddUserToListArgs,
    assertRemoveUserFromListArgs,
    assertGetListMembersArgs,
    assertGetUserListsArgs,
    assertGetHashtagAnalyticsArgs
} from './types.js';
import { TOOLS } from './tools.js';
import { promises as fs } from 'fs';

const server = new Server({
    name: 'twitter-mcp-server',
    version: '0.0.1',
}, {
    capabilities: {
        tools: TOOLS
    }
});

server.setRequestHandler(ListToolsRequestSchema, async () => ({
    tools: Object.entries(TOOLS).map(([name, tool]) => ({
        name,
        ...tool
    }))
}));

server.setRequestHandler(CallToolRequestSchema, async (request) => {
    const client = getTwitterClient();

    if (request.params.name === 'postTweet') {
        assertPostTweetArgs(request.params.arguments);
        const tweet = await client.v2.tweet({ text: request.params.arguments.text });
        return {
            content: [{ type: 'text', text: `Tweet posted with id: ${tweet.data.id}` }],
        };
    }

    if (request.params.name === 'postTweetWithMedia') {
        assertPostTweetWithMediaArgs(request.params.arguments);
        const { text, mediaPath, mediaType, altText } = request.params.arguments;

        try {
            // Read the media file
            const mediaBuffer = await fs.readFile(mediaPath);

            // Upload the media
            const mediaId = await client.v1.uploadMedia(mediaBuffer, { mimeType: mediaType });

            // Set alt text if provided
            if (altText) {
                await client.v1.createMediaMetadata(mediaId, { alt_text: { text: altText } });
            }

            // Post the tweet with media
            const tweet = await client.v2.tweet({
                text,
                media: { media_ids: [mediaId] }
            });

            return {
                content: [{ type: 'text', text: `Tweet posted with media, id: ${tweet.data.id}` }],
            };
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to post tweet with media: ${error.message}`);
            }
            throw error;
        }
    }

    if (request.params.name === 'searchTweets') {
        assertSearchTweetsArgs(request.params.arguments);
        const { query, since, until, tweetFields } = request.params.arguments;
        
        const searchOptions: any = {};
        if (since) searchOptions.start_time = since;
        if (until) searchOptions.end_time = until;
        if (tweetFields && tweetFields.length > 0) {
            searchOptions['tweet.fields'] = tweetFields.join(',');
        }

        const tweets = await client.v2.search(query, searchOptions);
        return {
            content: [{ 
                type: 'text', 
                text: `Search results: ${JSON.stringify(tweets.data, null, 2)}` 
            }],
        };
    }

    if (request.params.name === 'replyToTweet') {
        assertReplyToTweetArgs(request.params.arguments);
        const reply = await client.v2.tweet({
            text: request.params.arguments.text,
            reply: {
                in_reply_to_tweet_id: request.params.arguments.tweetId,
            },
        });
        return {
            content: [{ type: 'text', text: `Replied to tweet ${request.params.arguments.tweetId} with id: ${reply.data.id}` }],
        };
    }

    if (request.params.name === 'getUserTimeline') {
        assertGetUserTimelineArgs(request.params.arguments);
        const userResponse = await client.v2.userByUsername(request.params.arguments.username);
        if (!userResponse.data) {
            throw new Error(`User not found: ${request.params.arguments.username}`);
        }
        const tweets = await client.v2.userTimeline(userResponse.data.id);
        return {
            content: [{ 
                type: 'text', 
                text: `User timeline: ${JSON.stringify(tweets.data, null, 2)}` 
            }],
        };
    }

    if (request.params.name === 'getTweetById') {
        assertGetTweetByIdArgs(request.params.arguments);
        const tweet = await client.v2.singleTweet(request.params.arguments.tweetId);
        if (!tweet.data) {
            throw new Error(`Tweet not found: ${request.params.arguments.tweetId}`);
        }
        return {
            content: [{ 
                type: 'text', 
                text: `Tweet: ${JSON.stringify(tweet.data, null, 2)}` 
            }],
        };
    }

    if (request.params.name === 'getUserInfo') {
        assertGetUserInfoArgs(request.params.arguments);
        const user = await client.v2.userByUsername(
            request.params.arguments.username,
            { 
                'user.fields': ['description', 'public_metrics', 'profile_image_url', 'verified']
            }
        );
        if (!user.data) {
            throw new Error(`User not found: ${request.params.arguments.username}`);
        }
        return {
            content: [{ 
                type: 'text', 
                text: `User info: ${JSON.stringify(user.data, null, 2)}` 
            }],
        };
    }

    if (request.params.name === 'getTweetsByIds') {
        assertGetTweetsByIdsArgs(request.params.arguments);
        const { tweetIds, tweetFields } = request.params.arguments;
        
        const options: any = {};
        if (tweetFields && tweetFields.length > 0) {
            options['tweet.fields'] = tweetFields.join(',');
        }

        const tweets = await client.v2.tweets(tweetIds, options);
        if (!tweets.data || tweets.data.length === 0) {
            throw new Error('No tweets found for the provided IDs');
        }
        return {
            content: [{ 
                type: 'text', 
                text: `Tweets: ${JSON.stringify(tweets.data, null, 2)}` 
            }],
        };
    }

    if (request.params.name === 'likeTweet') {
        assertLikeTweetArgs(request.params.arguments);
        try {
            const userId = await client.v2.me().then(response => response.data.id);
            await client.v2.like(userId, request.params.arguments.tweetId);
            return {
                content: [{ type: 'text', text: `Successfully liked tweet: ${request.params.arguments.tweetId}` }],
            };
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to like tweet: ${error.message}`);
            }
            throw error;
        }
    }

    if (request.params.name === 'unlikeTweet') {
        assertUnlikeTweetArgs(request.params.arguments);
        try {
            const userId = await client.v2.me().then(response => response.data.id);
            await client.v2.unlike(userId, request.params.arguments.tweetId);
            return {
                content: [{ type: 'text', text: `Successfully unliked tweet: ${request.params.arguments.tweetId}` }],
            };
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to unlike tweet: ${error.message}`);
            }
            throw error;
        }
    }

    if (request.params.name === 'getLikedTweets') {
        assertGetLikedTweetsArgs(request.params.arguments);
        try {
            const { userId, maxResults, tweetFields } = request.params.arguments;
            
            const options: any = {
                max_results: maxResults || 100
            };
            
            if (tweetFields && tweetFields.length > 0) {
                options['tweet.fields'] = tweetFields.join(',');
            }

            const likedTweets = await client.v2.userLikedTweets(userId, options);
            if (!likedTweets.data) {
                return {
                    content: [{ type: 'text', text: 'No liked tweets found' }],
                };
            }

            return {
                content: [{ 
                    type: 'text', 
                    text: `Liked tweets: ${JSON.stringify(likedTweets.data, null, 2)}` 
                }],
            };
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to get liked tweets: ${error.message}`);
            }
            throw error;
        }
    }

    if (request.params.name === 'retweet') {
        assertRetweetArgs(request.params.arguments);
        try {
            const userId = await client.v2.me().then(response => response.data.id);
            await client.v2.retweet(userId, request.params.arguments.tweetId);
            return {
                content: [{ type: 'text', text: `Successfully retweeted tweet: ${request.params.arguments.tweetId}` }],
            };
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to retweet: ${error.message}`);
            }
            throw error;
        }
    }

    if (request.params.name === 'undoRetweet') {
        assertUndoRetweetArgs(request.params.arguments);
        try {
            const userId = await client.v2.me().then(response => response.data.id);
            await client.v2.unretweet(userId, request.params.arguments.tweetId);
            return {
                content: [{ type: 'text', text: `Successfully undid retweet: ${request.params.arguments.tweetId}` }],
            };
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to undo retweet: ${error.message}`);
            }
            throw error;
        }
    }

    if (request.params.name === 'getRetweets') {
        assertGetRetweetsArgs(request.params.arguments);
        try {
            const { tweetId, maxResults, userFields } = request.params.arguments;
            
            const options: any = {
                max_results: maxResults || 100
            };
            
            if (userFields && userFields.length > 0) {
                options['user.fields'] = userFields.join(',');
            }

            const retweets = await client.v2.tweetRetweetedBy(tweetId, options);
            if (!retweets.data) {
                return {
                    content: [{ type: 'text', text: 'No retweets found' }],
                };
            }

            return {
                content: [{ 
                    type: 'text', 
                    text: `Users who retweeted: ${JSON.stringify(retweets.data, null, 2)}` 
                }],
            };
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to get retweets: ${error.message}`);
            }
            throw error;
        }
    }

    if (request.params.name === 'followUser') {
        assertFollowUserArgs(request.params.arguments);
        try {
            const userId = await client.v2.me().then(response => response.data.id);
            const targetUser = await client.v2.userByUsername(request.params.arguments.username);
            if (!targetUser.data) {
                throw new Error(`User not found: ${request.params.arguments.username}`);
            }
            await client.v2.follow(userId, targetUser.data.id);
            return {
                content: [{ type: 'text', text: `Successfully followed user: ${request.params.arguments.username}` }],
            };
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to follow user: ${error.message}`);
            }
            throw error;
        }
    }

    if (request.params.name === 'unfollowUser') {
        assertUnfollowUserArgs(request.params.arguments);
        try {
            const userId = await client.v2.me().then(response => response.data.id);
            const targetUser = await client.v2.userByUsername(request.params.arguments.username);
            if (!targetUser.data) {
                throw new Error(`User not found: ${request.params.arguments.username}`);
            }
            await client.v2.unfollow(userId, targetUser.data.id);
            return {
                content: [{ type: 'text', text: `Successfully unfollowed user: ${request.params.arguments.username}` }],
            };
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to unfollow user: ${error.message}`);
            }
            throw error;
        }
    }

    if (request.params.name === 'getFollowers') {
        assertGetFollowersArgs(request.params.arguments);
        try {
            const { username, maxResults, userFields } = request.params.arguments;
            
            const targetUser = await client.v2.userByUsername(username);
            if (!targetUser.data) {
                throw new Error(`User not found: ${username}`);
            }

            const options: any = {
                max_results: maxResults || 100
            };
            
            if (userFields && userFields.length > 0) {
                options['user.fields'] = userFields.join(',');
            }

            const followers = await client.v2.followers(targetUser.data.id, options);
            if (!followers.data) {
                return {
                    content: [{ type: 'text', text: 'No followers found' }],
                };
            }

            return {
                content: [{ 
                    type: 'text', 
                    text: `Followers: ${JSON.stringify(followers.data, null, 2)}` 
                }],
            };
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to get followers: ${error.message}`);
            }
            throw error;
        }
    }

    if (request.params.name === 'getFollowing') {
        assertGetFollowingArgs(request.params.arguments);
        try {
            const { username, maxResults, userFields } = request.params.arguments;
            
            const targetUser = await client.v2.userByUsername(username);
            if (!targetUser.data) {
                throw new Error(`User not found: ${username}`);
            }

            const options: any = {
                max_results: maxResults || 100
            };
            
            if (userFields && userFields.length > 0) {
                options['user.fields'] = userFields.join(',');
            }

            const following = await client.v2.following(targetUser.data.id, options);
            if (!following.data) {
                return {
                    content: [{ type: 'text', text: 'No following users found' }],
                };
            }

            return {
                content: [{ 
                    type: 'text', 
                    text: `Following: ${JSON.stringify(following.data, null, 2)}` 
                }],
            };
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to get following users: ${error.message}`);
            }
            throw error;
        }
    }

    if (request.params.name === 'createList') {
        assertCreateListArgs(request.params.arguments);
        try {
            const { name, description, private: isPrivate } = request.params.arguments;
            const list = await client.v2.createList({
                name,
                description,
                private: isPrivate
            });
            return {
                content: [{ type: 'text', text: `List created with id: ${list.data.id}` }],
            };
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to create list: ${error.message}`);
            }
            throw error;
        }
    }

    if (request.params.name === 'addUserToList') {
        assertAddUserToListArgs(request.params.arguments);
        try {
            const { listId, username } = request.params.arguments;
            const targetUser = await client.v2.userByUsername(username);
            if (!targetUser.data) {
                throw new Error(`User not found: ${username}`);
            }
            await client.v2.addListMember(listId, targetUser.data.id);
            return {
                content: [{ type: 'text', text: `Successfully added user ${username} to list ${listId}` }],
            };
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to add user to list: ${error.message}`);
            }
            throw error;
        }
    }

    if (request.params.name === 'removeUserFromList') {
        assertRemoveUserFromListArgs(request.params.arguments);
        try {
            const { listId, username } = request.params.arguments;
            const targetUser = await client.v2.userByUsername(username);
            if (!targetUser.data) {
                throw new Error(`User not found: ${username}`);
            }
            await client.v2.removeListMember(listId, targetUser.data.id);
            return {
                content: [{ type: 'text', text: `Successfully removed user ${username} from list ${listId}` }],
            };
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to remove user from list: ${error.message}`);
            }
            throw error;
        }
    }

    if (request.params.name === 'getListMembers') {
        assertGetListMembersArgs(request.params.arguments);
        try {
            const { listId, maxResults, userFields } = request.params.arguments;
            
            const options: any = {
                max_results: maxResults || 100
            };
            
            if (userFields && userFields.length > 0) {
                options['user.fields'] = userFields.join(',');
            }

            const members = await client.v2.listMembers(listId, options);
            if (!members.data) {
                return {
                    content: [{ type: 'text', text: 'No members found in list' }],
                };
            }

            return {
                content: [{ 
                    type: 'text', 
                    text: `List members: ${JSON.stringify(members.data, null, 2)}` 
                }],
            };
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to get list members: ${error.message}`);
            }
            throw error;
        }
    }

    if (request.params.name === 'getUserLists') {
        assertGetUserListsArgs(request.params.arguments);
        try {
            const { username, maxResults, listFields } = request.params.arguments;
            
            const targetUser = await client.v2.userByUsername(username);
            if (!targetUser.data) {
                throw new Error(`User not found: ${username}`);
            }

            const options: any = {
                max_results: maxResults || 100
            };
            
            if (listFields && listFields.length > 0) {
                options['list.fields'] = listFields.join(',');
            }

            const lists = await client.v2.listsOwned(targetUser.data.id, options);
            if (!lists.data) {
                return {
                    content: [{ type: 'text', text: 'No lists found' }],
                };
            }

            return {
                content: [{ 
                    type: 'text', 
                    text: `User's lists: ${JSON.stringify(lists.data, null, 2)}` 
                }],
            };
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to get user's lists: ${error.message}`);
            }
            throw error;
        }
    }

    if (request.params.name === 'getHashtagAnalytics') {
        assertGetHashtagAnalyticsArgs(request.params.arguments);
        try {
            const { hashtag, maxResults, tweetFields } = request.params.arguments;

            // Construct search query
            const query = `#${hashtag}`;
            const options: any = {
                max_results: maxResults || 100,
                'tweet.fields': [
                    'public_metrics',
                    'created_at',
                    'author_id',
                    ...(tweetFields || [])
                ].join(',')
            };

            // Search for tweets with the hashtag
            const searchResult = await client.v2.search(query, options);
            const tweets = Array.isArray(searchResult.data) ? searchResult.data : [];

            // Calculate engagement metrics
            type TweetMetrics = {
                like_count?: number;
                retweet_count?: number;
                reply_count?: number;
                quote_count?: number;
            };

            type EngagementMetrics = {
                likes: number;
                retweets: number;
                replies: number;
                quotes: number;
            };

            const totalEngagement = tweets.reduce((acc: EngagementMetrics, tweet: { public_metrics?: TweetMetrics }) => {
                const metrics = tweet.public_metrics || {};
                return {
                    likes: acc.likes + (metrics.like_count || 0),
                    retweets: acc.retweets + (metrics.retweet_count || 0),
                    replies: acc.replies + (metrics.reply_count || 0),
                    quotes: acc.quotes + (metrics.quote_count || 0)
                };
            }, { likes: 0, retweets: 0, replies: 0, quotes: 0 });

            // Format the response
            const analytics = {
                hashtag,
                tweet_count: tweets.length,
                total_engagement: totalEngagement,
                engagement_rate: tweets.length > 0 ? {
                    likes_per_tweet: totalEngagement.likes / tweets.length,
                    retweets_per_tweet: totalEngagement.retweets / tweets.length,
                    replies_per_tweet: totalEngagement.replies / tweets.length,
                    quotes_per_tweet: totalEngagement.quotes / tweets.length
                } : null,
                recent_tweets: tweets.map(tweet => ({
                    id: tweet.id,
                    text: tweet.text,
                    created_at: tweet.created_at,
                    metrics: tweet.public_metrics,
                    author_id: tweet.author_id
                }))
            };

            return {
                content: [{ 
                    type: 'text', 
                    text: JSON.stringify(analytics, null, 2)
                }],
            };
        } catch (error) {
            if (error instanceof Error) {
                throw new Error(`Failed to get hashtag analytics: ${error.message}`);
            }
            throw error;
        }
    }

    throw new Error(`Tool not found: ${request.params.name}`);
});

const transport = new StdioServerTransport();
server.connect(transport).catch(console.error);

================
File: src/tools.ts
================
export const TOOLS = {
    postTweet: {
        description: 'Post a tweet to Twitter',
        inputSchema: {
            type: 'object',
            properties: {
                text: { type: 'string', description: 'The text of the tweet' },
            },
            required: ['text'],
        },
    },
    postTweetWithMedia: {
        description: 'Post a tweet with media attachment to Twitter',
        inputSchema: {
            type: 'object',
            properties: {
                text: { type: 'string', description: 'The text of the tweet' },
                mediaPath: { type: 'string', description: 'Local file path to the media to upload' },
                mediaType: { 
                    type: 'string', 
                    enum: ['image/jpeg', 'image/png', 'image/gif', 'video/mp4'],
                    description: 'MIME type of the media file'
                },
                altText: { 
                    type: 'string', 
                    description: 'Alternative text for the media (accessibility)'
                }
            },
            required: ['text', 'mediaPath', 'mediaType'],
        },
    },
    likeTweet: {
        description: 'Like a tweet by its ID',
        inputSchema: {
            type: 'object',
            properties: {
                tweetId: { type: 'string', description: 'The ID of the tweet to like' }
            },
            required: ['tweetId'],
        },
    },
    unlikeTweet: {
        description: 'Unlike a previously liked tweet',
        inputSchema: {
            type: 'object',
            properties: {
                tweetId: { type: 'string', description: 'The ID of the tweet to unlike' }
            },
            required: ['tweetId'],
        },
    },
    getLikedTweets: {
        description: 'Get a list of tweets liked by a user',
        inputSchema: {
            type: 'object',
            properties: {
                userId: { type: 'string', description: 'The ID of the user whose likes to fetch' },
                maxResults: { 
                    type: 'number', 
                    description: 'The maximum number of results to return (default: 100, max: 100)',
                    minimum: 1,
                    maximum: 100
                },
                tweetFields: { 
                    type: 'array', 
                    items: { 
                        type: 'string',
                        enum: ['created_at', 'author_id', 'conversation_id', 'public_metrics', 'entities', 'context_annotations']
                    },
                    description: 'Additional tweet fields to include in the response'
                },
            },
            required: ['userId'],
        },
    },
    searchTweets: {
        description: 'Search for tweets on Twitter with advanced options',
        inputSchema: {
            type: 'object',
            properties: {
                query: { type: 'string', description: 'The query to search for' },
                since: { type: 'string', description: 'Start time for search (ISO 8601 format)' },
                until: { type: 'string', description: 'End time for search (ISO 8601 format)' },
                tweetFields: { 
                    type: 'array', 
                    items: { 
                        type: 'string',
                        enum: ['created_at', 'author_id', 'conversation_id', 'public_metrics', 'entities', 'context_annotations']
                    },
                    description: 'Additional tweet fields to include in the response'
                },
            },
            required: ['query'],
        },
    },
    replyToTweet: {
        description: 'Reply to a tweet on Twitter',
        inputSchema: {
            type: 'object',
            properties: {
                tweetId: { type: 'string', description: 'The ID of the tweet to reply to' },
                text: { type: 'string', description: 'The text of the reply' },
            },
            required: ['tweetId', 'text'],
        },
    },
    getUserTimeline: {
        description: 'Get recent tweets from a user timeline',
        inputSchema: {
            type: 'object',
            properties: {
                username: { type: 'string', description: 'The username of the user' },
            },
            required: ['username'],
        },
    },
    getTweetById: {
        description: 'Get a tweet by its ID',
        inputSchema: {
            type: 'object',
            properties: {
                tweetId: { type: 'string', description: 'The ID of the tweet' },
            },
            required: ['tweetId'],
        },
    },
    getUserInfo: {
        description: 'Get information about a Twitter user',
        inputSchema: {
            type: 'object',
            properties: {
                username: { type: 'string', description: 'The username of the user' },
            },
            required: ['username'],
        },
    },
    getTweetsByIds: {
        description: 'Get multiple tweets by their IDs',
        inputSchema: {
            type: 'object',
            properties: {
                tweetIds: { 
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Array of tweet IDs to fetch',
                    maxItems: 100
                },
                tweetFields: { 
                    type: 'array', 
                    items: { 
                        type: 'string',
                        enum: ['created_at', 'author_id', 'conversation_id', 'public_metrics', 'entities', 'context_annotations']
                    },
                    description: 'Additional tweet fields to include in the response'
                },
            },
            required: ['tweetIds'],
        },
    },
    retweet: {
        description: 'Retweet a tweet by its ID',
        inputSchema: {
            type: 'object',
            properties: {
                tweetId: { type: 'string', description: 'The ID of the tweet to retweet' }
            },
            required: ['tweetId'],
        },
    },
    undoRetweet: {
        description: 'Undo a retweet by its ID',
        inputSchema: {
            type: 'object',
            properties: {
                tweetId: { type: 'string', description: 'The ID of the tweet to un-retweet' }
            },
            required: ['tweetId'],
        },
    },
    getRetweets: {
        description: 'Get a list of retweets of a tweet',
        inputSchema: {
            type: 'object',
            properties: {
                tweetId: { type: 'string', description: 'The ID of the tweet to get retweets for' },
                maxResults: { 
                    type: 'number', 
                    description: 'The maximum number of results to return (default: 100, max: 100)',
                    minimum: 1,
                    maximum: 100
                },
                userFields: { 
                    type: 'array', 
                    items: { 
                        type: 'string',
                        enum: ['description', 'profile_image_url', 'public_metrics', 'verified']
                    },
                    description: 'Additional user fields to include in the response'
                },
            },
            required: ['tweetId'],
        },
    },
    followUser: {
        description: 'Follow a user by their username',
        inputSchema: {
            type: 'object',
            properties: {
                username: { type: 'string', description: 'The username of the user to follow' }
            },
            required: ['username'],
        },
    },
    unfollowUser: {
        description: 'Unfollow a user by their username',
        inputSchema: {
            type: 'object',
            properties: {
                username: { type: 'string', description: 'The username of the user to unfollow' }
            },
            required: ['username'],
        },
    },
    getFollowers: {
        description: 'Get a list of followers for a user',
        inputSchema: {
            type: 'object',
            properties: {
                username: { type: 'string', description: 'The username of the user whose followers to fetch' },
                maxResults: { 
                    type: 'number', 
                    description: 'The maximum number of results to return (default: 100, max: 1000)',
                    minimum: 1,
                    maximum: 1000
                },
                userFields: { 
                    type: 'array', 
                    items: { 
                        type: 'string',
                        enum: ['description', 'profile_image_url', 'public_metrics', 'verified', 'location', 'url']
                    },
                    description: 'Additional user fields to include in the response'
                },
            },
            required: ['username'],
        },
    },
    getFollowing: {
        description: 'Get a list of users that a user is following',
        inputSchema: {
            type: 'object',
            properties: {
                username: { type: 'string', description: 'The username of the user whose following list to fetch' },
                maxResults: { 
                    type: 'number', 
                    description: 'The maximum number of results to return (default: 100, max: 1000)',
                    minimum: 1,
                    maximum: 1000
                },
                userFields: { 
                    type: 'array', 
                    items: { 
                        type: 'string',
                        enum: ['description', 'profile_image_url', 'public_metrics', 'verified', 'location', 'url']
                    },
                    description: 'Additional user fields to include in the response'
                },
            },
            required: ['username'],
        },
    },
    createList: {
        description: 'Create a new Twitter list',
        inputSchema: {
            type: 'object',
            properties: {
                name: { type: 'string', description: 'The name of the list' },
                description: { type: 'string', description: 'A description of the list' },
                private: { type: 'boolean', description: 'Whether the list should be private' }
            },
            required: ['name'],
        },
    },
    addUserToList: {
        description: 'Add a user to a Twitter list',
        inputSchema: {
            type: 'object',
            properties: {
                listId: { type: 'string', description: 'The ID of the list' },
                username: { type: 'string', description: 'The username of the user to add' }
            },
            required: ['listId', 'username'],
        },
    },
    removeUserFromList: {
        description: 'Remove a user from a Twitter list',
        inputSchema: {
            type: 'object',
            properties: {
                listId: { type: 'string', description: 'The ID of the list' },
                username: { type: 'string', description: 'The username of the user to remove' }
            },
            required: ['listId', 'username'],
        },
    },
    getListMembers: {
        description: 'Get members of a Twitter list',
        inputSchema: {
            type: 'object',
            properties: {
                listId: { type: 'string', description: 'The ID of the list' },
                maxResults: { 
                    type: 'number', 
                    description: 'The maximum number of results to return (default: 100, max: 100)',
                    minimum: 1,
                    maximum: 100
                },
                userFields: { 
                    type: 'array', 
                    items: { 
                        type: 'string',
                        enum: ['description', 'profile_image_url', 'public_metrics', 'verified', 'location', 'url']
                    },
                    description: 'Additional user fields to include in the response'
                },
            },
            required: ['listId'],
        },
    },
    getUserLists: {
        description: 'Get lists owned by a user',
        inputSchema: {
            type: 'object',
            properties: {
                username: { type: 'string', description: 'The username of the user whose lists to fetch' },
                maxResults: { 
                    type: 'number', 
                    description: 'The maximum number of results to return (default: 100, max: 100)',
                    minimum: 1,
                    maximum: 100
                },
                listFields: { 
                    type: 'array', 
                    items: { 
                        type: 'string',
                        enum: ['created_at', 'follower_count', 'member_count', 'private', 'description']
                    },
                    description: 'Additional list fields to include in the response'
                },
            },
            required: ['username'],
        },
    },
    getHashtagAnalytics: {
        description: 'Get analytics for a hashtag using Twitter search',
        inputSchema: {
            type: 'object',
            properties: {
                hashtag: { 
                    type: 'string', 
                    description: 'The hashtag to analyze (without #)' 
                },
                maxResults: { 
                    type: 'number', 
                    description: 'The maximum number of tweets to analyze (default: 100, max: 100)',
                    minimum: 10,
                    maximum: 100
                },
                tweetFields: { 
                    type: 'array', 
                    items: { 
                        type: 'string',
                        enum: [
                            'created_at',
                            'author_id',
                            'conversation_id',
                            'public_metrics',
                            'entities',
                            'context_annotations'
                        ]
                    },
                    description: 'Additional tweet fields to include in the response'
                }
            },
            required: ['hashtag'],
        },
    },
};

================
File: src/twitterClient.ts
================
import { TwitterApi } from 'twitter-api-v2';
import dotenv from 'dotenv';

dotenv.config();

export function getTwitterClient() {
    if (!process.env.X_API_KEY || !process.env.X_API_SECRET || !process.env.X_ACCESS_TOKEN || !process.env.X_ACCESS_TOKEN_SECRET) {
        throw new Error('Twitter API credentials not found in environment variables');
    }

    const client = new TwitterApi({
        appKey: process.env.X_API_KEY,
        appSecret: process.env.X_API_SECRET,
        accessToken: process.env.X_ACCESS_TOKEN,
        accessSecret: process.env.X_ACCESS_TOKEN_SECRET,
    });

    return client;
}

================
File: src/types.ts
================
export interface PostTweetArgs {
    text: string;
}

export interface PostTweetWithMediaArgs {
    text: string;
    mediaPath: string;
    mediaType: 'image/jpeg' | 'image/png' | 'image/gif' | 'video/mp4';
    altText?: string;
}

export interface SearchTweetsArgs {
    query: string;
    since?: string;
    until?: string;
    tweetFields?: string[];
}

export interface ReplyToTweetArgs {
    tweetId: string;
    text: string;
}

export interface GetUserTimelineArgs {
    username: string;
}

export interface GetTweetByIdArgs {
    tweetId: string;
}

export interface GetUserInfoArgs {
    username: string;
}

export interface GetTweetsByIdsArgs {
    tweetIds: string[];
    tweetFields?: string[];
}

export interface LikeTweetArgs {
    tweetId: string;
}

export interface UnlikeTweetArgs {
    tweetId: string;
}

export interface GetLikedTweetsArgs {
    userId: string;
    maxResults?: number;
    tweetFields?: string[];
}

export interface RetweetArgs {
    tweetId: string;
}

export interface UndoRetweetArgs {
    tweetId: string;
}

export interface GetRetweetsArgs {
    tweetId: string;
    maxResults?: number;
    userFields?: string[];
}

export interface FollowUserArgs {
    username: string;
}

export interface UnfollowUserArgs {
    username: string;
}

export interface GetFollowersArgs {
    username: string;
    maxResults?: number;
    userFields?: string[];
}

export interface GetFollowingArgs {
    username: string;
    maxResults?: number;
    userFields?: string[];
}

export interface CreateListArgs {
    name: string;
    description?: string;
    private?: boolean;
}

export interface AddUserToListArgs {
    listId: string;
    username: string;
}

export interface RemoveUserFromListArgs {
    listId: string;
    username: string;
}

export interface GetListMembersArgs {
    listId: string;
    maxResults?: number;
    userFields?: string[];
}

export interface GetUserListsArgs {
    username: string;
    maxResults?: number;
    listFields?: string[];
}

export interface GetHashtagAnalyticsArgs {
    hashtag: string;
    maxResults?: number;
    tweetFields?: string[];
}

export function assertPostTweetArgs(args: unknown): asserts args is PostTweetArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('text' in args) || typeof (args as any).text !== 'string') {
        throw new Error('Invalid arguments: expected text string');
    }
}

export function assertPostTweetWithMediaArgs(args: unknown): asserts args is PostTweetWithMediaArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('text' in args) || typeof (args as any).text !== 'string') {
        throw new Error('Invalid arguments: expected text string');
    }
    if (!('mediaPath' in args) || typeof (args as any).mediaPath !== 'string') {
        throw new Error('Invalid arguments: expected mediaPath string');
    }
    if (!('mediaType' in args) || typeof (args as any).mediaType !== 'string') {
        throw new Error('Invalid arguments: expected mediaType string');
    }
    const validMediaTypes = ['image/jpeg', 'image/png', 'image/gif', 'video/mp4'];
    if (!validMediaTypes.includes((args as any).mediaType)) {
        throw new Error(`Invalid arguments: mediaType must be one of: ${validMediaTypes.join(', ')}`);
    }
    if ('altText' in args && typeof (args as any).altText !== 'string') {
        throw new Error('Invalid arguments: expected altText to be a string');
    }
}

export function assertSearchTweetsArgs(args: unknown): asserts args is SearchTweetsArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('query' in args) || typeof (args as any).query !== 'string') {
        throw new Error('Invalid arguments: expected query string');
    }
    if ('since' in args && typeof (args as any).since !== 'string') {
        throw new Error('Invalid arguments: expected since to be an ISO 8601 date string');
    }
    if ('until' in args && typeof (args as any).until !== 'string') {
        throw new Error('Invalid arguments: expected until to be an ISO 8601 date string');
    }
    if ('tweetFields' in args) {
        if (!Array.isArray((args as any).tweetFields)) {
            throw new Error('Invalid arguments: expected tweetFields to be an array');
        }
        for (const field of (args as any).tweetFields) {
            if (typeof field !== 'string') {
                throw new Error('Invalid arguments: expected tweetFields to be an array of strings');
            }
        }
    }
}

export function assertReplyToTweetArgs(args: unknown): asserts args is ReplyToTweetArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('tweetId' in args) || typeof (args as any).tweetId !== 'string') {
        throw new Error('Invalid arguments: expected tweetId string');
    }
    if (!('text' in args) || typeof (args as any).text !== 'string') {
        throw new Error('Invalid arguments: expected text string');
    }
}

export function assertGetUserTimelineArgs(args: unknown): asserts args is GetUserTimelineArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('username' in args) || typeof (args as any).username !== 'string') {
        throw new Error('Invalid arguments: expected username string');
    }
}

export function assertGetTweetByIdArgs(args: unknown): asserts args is GetTweetByIdArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('tweetId' in args) || typeof (args as any).tweetId !== 'string') {
        throw new Error('Invalid arguments: expected tweetId string');
    }
}

export function assertGetUserInfoArgs(args: unknown): asserts args is GetUserInfoArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('username' in args) || typeof (args as any).username !== 'string') {
        throw new Error('Invalid arguments: expected username string');
    }
}

export function assertGetTweetsByIdsArgs(args: unknown): asserts args is GetTweetsByIdsArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('tweetIds' in args) || !Array.isArray((args as any).tweetIds)) {
        throw new Error('Invalid arguments: expected tweetIds array');
    }
    if ((args as any).tweetIds.length === 0) {
        throw new Error('Invalid arguments: tweetIds array cannot be empty');
    }
    if ((args as any).tweetIds.length > 100) {
        throw new Error('Invalid arguments: cannot fetch more than 100 tweets at once');
    }
    for (const id of (args as any).tweetIds) {
        if (typeof id !== 'string') {
            throw new Error('Invalid arguments: expected tweetIds to be an array of strings');
        }
    }
    if ('tweetFields' in args) {
        if (!Array.isArray((args as any).tweetFields)) {
            throw new Error('Invalid arguments: expected tweetFields to be an array');
        }
        for (const field of (args as any).tweetFields) {
            if (typeof field !== 'string') {
                throw new Error('Invalid arguments: expected tweetFields to be an array of strings');
            }
        }
    }
}

export function assertLikeTweetArgs(args: unknown): asserts args is LikeTweetArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('tweetId' in args) || typeof (args as any).tweetId !== 'string') {
        throw new Error('Invalid arguments: expected tweetId string');
    }
}

export function assertUnlikeTweetArgs(args: unknown): asserts args is UnlikeTweetArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('tweetId' in args) || typeof (args as any).tweetId !== 'string') {
        throw new Error('Invalid arguments: expected tweetId string');
    }
}

export function assertGetLikedTweetsArgs(args: unknown): asserts args is GetLikedTweetsArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('userId' in args) || typeof (args as any).userId !== 'string') {
        throw new Error('Invalid arguments: expected userId string');
    }
    if ('maxResults' in args) {
        const maxResults = (args as any).maxResults;
        if (typeof maxResults !== 'number' || maxResults < 1 || maxResults > 100) {
            throw new Error('Invalid arguments: maxResults must be a number between 1 and 100');
        }
    }
    if ('tweetFields' in args) {
        if (!Array.isArray((args as any).tweetFields)) {
            throw new Error('Invalid arguments: expected tweetFields to be an array');
        }
        for (const field of (args as any).tweetFields) {
            if (typeof field !== 'string') {
                throw new Error('Invalid arguments: expected tweetFields to be an array of strings');
            }
        }
    }
}

export function assertRetweetArgs(args: unknown): asserts args is RetweetArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('tweetId' in args) || typeof (args as any).tweetId !== 'string') {
        throw new Error('Invalid arguments: expected tweetId string');
    }
}

export function assertUndoRetweetArgs(args: unknown): asserts args is UndoRetweetArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('tweetId' in args) || typeof (args as any).tweetId !== 'string') {
        throw new Error('Invalid arguments: expected tweetId string');
    }
}

export function assertGetRetweetsArgs(args: unknown): asserts args is GetRetweetsArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('tweetId' in args) || typeof (args as any).tweetId !== 'string') {
        throw new Error('Invalid arguments: expected tweetId string');
    }
    if ('maxResults' in args) {
        const maxResults = (args as any).maxResults;
        if (typeof maxResults !== 'number' || maxResults < 1 || maxResults > 100) {
            throw new Error('Invalid arguments: maxResults must be a number between 1 and 100');
        }
    }
    if ('userFields' in args) {
        if (!Array.isArray((args as any).userFields)) {
            throw new Error('Invalid arguments: expected userFields to be an array');
        }
        for (const field of (args as any).userFields) {
            if (typeof field !== 'string') {
                throw new Error('Invalid arguments: expected userFields to be an array of strings');
            }
        }
    }
}

export function assertFollowUserArgs(args: unknown): asserts args is FollowUserArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('username' in args) || typeof (args as any).username !== 'string') {
        throw new Error('Invalid arguments: expected username string');
    }
}

export function assertUnfollowUserArgs(args: unknown): asserts args is UnfollowUserArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('username' in args) || typeof (args as any).username !== 'string') {
        throw new Error('Invalid arguments: expected username string');
    }
}

export function assertGetFollowersArgs(args: unknown): asserts args is GetFollowersArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('username' in args) || typeof (args as any).username !== 'string') {
        throw new Error('Invalid arguments: expected username string');
    }
    if ('maxResults' in args) {
        const maxResults = (args as any).maxResults;
        if (typeof maxResults !== 'number' || maxResults < 1 || maxResults > 1000) {
            throw new Error('Invalid arguments: maxResults must be a number between 1 and 1000');
        }
    }
    if ('userFields' in args) {
        if (!Array.isArray((args as any).userFields)) {
            throw new Error('Invalid arguments: expected userFields to be an array');
        }
        for (const field of (args as any).userFields) {
            if (typeof field !== 'string') {
                throw new Error('Invalid arguments: expected userFields to be an array of strings');
            }
        }
    }
}

export function assertGetFollowingArgs(args: unknown): asserts args is GetFollowingArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('username' in args) || typeof (args as any).username !== 'string') {
        throw new Error('Invalid arguments: expected username string');
    }
    if ('maxResults' in args) {
        const maxResults = (args as any).maxResults;
        if (typeof maxResults !== 'number' || maxResults < 1 || maxResults > 1000) {
            throw new Error('Invalid arguments: maxResults must be a number between 1 and 1000');
        }
    }
    if ('userFields' in args) {
        if (!Array.isArray((args as any).userFields)) {
            throw new Error('Invalid arguments: expected userFields to be an array');
        }
        for (const field of (args as any).userFields) {
            if (typeof field !== 'string') {
                throw new Error('Invalid arguments: expected userFields to be an array of strings');
            }
        }
    }
}

export function assertCreateListArgs(args: unknown): asserts args is CreateListArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('name' in args) || typeof (args as any).name !== 'string') {
        throw new Error('Invalid arguments: expected name string');
    }
    if ('description' in args && typeof (args as any).description !== 'string') {
        throw new Error('Invalid arguments: expected description string');
    }
    if ('private' in args && typeof (args as any).private !== 'boolean') {
        throw new Error('Invalid arguments: expected private boolean');
    }
}

export function assertAddUserToListArgs(args: unknown): asserts args is AddUserToListArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('listId' in args) || typeof (args as any).listId !== 'string') {
        throw new Error('Invalid arguments: expected listId string');
    }
    if (!('username' in args) || typeof (args as any).username !== 'string') {
        throw new Error('Invalid arguments: expected username string');
    }
}

export function assertRemoveUserFromListArgs(args: unknown): asserts args is RemoveUserFromListArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('listId' in args) || typeof (args as any).listId !== 'string') {
        throw new Error('Invalid arguments: expected listId string');
    }
    if (!('username' in args) || typeof (args as any).username !== 'string') {
        throw new Error('Invalid arguments: expected username string');
    }
}

export function assertGetListMembersArgs(args: unknown): asserts args is GetListMembersArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('listId' in args) || typeof (args as any).listId !== 'string') {
        throw new Error('Invalid arguments: expected listId string');
    }
    if ('maxResults' in args) {
        const maxResults = (args as any).maxResults;
        if (typeof maxResults !== 'number' || maxResults < 1 || maxResults > 100) {
            throw new Error('Invalid arguments: maxResults must be a number between 1 and 100');
        }
    }
    if ('userFields' in args) {
        if (!Array.isArray((args as any).userFields)) {
            throw new Error('Invalid arguments: expected userFields to be an array');
        }
        for (const field of (args as any).userFields) {
            if (typeof field !== 'string') {
                throw new Error('Invalid arguments: expected userFields to be an array of strings');
            }
        }
    }
}

export function assertGetUserListsArgs(args: unknown): asserts args is GetUserListsArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('username' in args) || typeof (args as any).username !== 'string') {
        throw new Error('Invalid arguments: expected username string');
    }
    if ('maxResults' in args) {
        const maxResults = (args as any).maxResults;
        if (typeof maxResults !== 'number' || maxResults < 1 || maxResults > 100) {
            throw new Error('Invalid arguments: maxResults must be a number between 1 and 100');
        }
    }
    if ('listFields' in args) {
        if (!Array.isArray((args as any).listFields)) {
            throw new Error('Invalid arguments: expected listFields to be an array');
        }
        for (const field of (args as any).listFields) {
            if (typeof field !== 'string') {
                throw new Error('Invalid arguments: expected listFields to be an array of strings');
            }
        }
    }
}

export function assertGetHashtagAnalyticsArgs(args: unknown): asserts args is GetHashtagAnalyticsArgs {
    if (typeof args !== 'object' || args === null) {
        throw new Error('Invalid arguments: expected object');
    }
    if (!('hashtag' in args) || typeof (args as any).hashtag !== 'string') {
        throw new Error('Invalid arguments: expected hashtag string');
    }
    if ('maxResults' in args) {
        const maxResults = (args as any).maxResults;
        if (typeof maxResults !== 'number' || maxResults < 10 || maxResults > 100) {
            throw new Error('Invalid arguments: maxResults must be a number between 10 and 100');
        }
    }
    if ('tweetFields' in args) {
        if (!Array.isArray((args as any).tweetFields)) {
            throw new Error('Invalid arguments: expected tweetFields to be an array');
        }
        for (const field of (args as any).tweetFields) {
            if (typeof field !== 'string') {
                throw new Error('Invalid arguments: expected tweetFields to be an array of strings');
            }
        }
    }
}

================
File: .env.example
================
# X (Twitter) API Credentials
# Get these from the X Developer Portal (https://developer.twitter.com/en/portal/dashboard)
X_API_KEY=
X_API_SECRET=
X_ACCESS_TOKEN=
X_ACCESS_TOKEN_SECRET=

================
File: .gitignore
================
# Dependency directories
node_modules/

# Environment variables
.env

# Build output
dist/

# Logs
*.log

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

================
File: LICENSE
================
MIT License

Copyright (c) 2024 MCP Twitter Server Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: package.json
================
{
  "name": "mcp-twitter-server",
  "version": "0.0.2",
  "description": "A Model Context Protocol server for Twitter integration",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "type": "module",
  "bin": {
    "mcp-twitter-server": "dist/index.js"
  },
  "scripts": {
    "build": "tsc",
    "start": "node dist/index.js",
    "prepare": "npm run build"
  },
  "files": [
    "dist",
    "README.md",
    "LICENSE"
  ],
  "keywords": [
    "mcp",
    "twitter",
    "llm",
    "ai",
    "model-context-protocol",
    "claude",
    "anthropic",
    "x"
  ],
  "author": "Dennison Bertram",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/crazyrabbitLTC/mcp-twitter-server.git"
  },
  "bugs": {
    "url": "https://github.com/crazyrabbitLTC/mcp-twitter-server/issues"
  },
  "homepage": "https://github.com/crazyrabbitLTC/mcp-twitter-server#readme",
  "dependencies": {
    "@modelcontextprotocol/sdk": "^1.0.0",
    "twitter-api-v2": "^1.15.1",
    "zod": "^3.0.0",
    "dotenv": "^16.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "typescript": "^5.0.0"
  },
  "engines": {
    "node": ">=18"
  },
  "publishConfig": {
    "access": "public"
  }
}

================
File: README.md
================
# Twitter MCP Server

A Model Context Protocol (MCP) server that allows Large Language Models (LLMs) to interact with Twitter (X). This server provides tools for posting tweets, searching tweets, and replying to tweets.

## Features

- **Post Tweets:** Allows LLMs to post new tweets to your Twitter account
- **Search Tweets:** Allows LLMs to search for tweets based on keywords
- **Reply to Tweets:** Allows LLMs to reply to existing tweets, which can be used to make threads

## Prerequisites

Before you begin, ensure you have met the following requirements:

- **Node.js** (version 18 or higher) installed. You can download it from [nodejs.org](https://nodejs.org/)
- **npm** (comes with Node.js)
- A **Twitter Developer Account** and API keys (see [Twitter Developer Portal](https://developer.twitter.com/en/portal/dashboard)). You will need API Key, API Secret Key, Access Token, Access Token Secret
- **Claude for Desktop** installed. You can download it from [claude.ai/download](https://claude.ai/download)

## Installation

1. **Install the package:**
   ```bash
   npm install mcp-twitter-server
   ```

2. **Set up environment variables:**
   - Create a `.env` file in your project root
   - Add your Twitter API keys and access tokens:
   ```env
   # Twitter API Credentials
   X_API_KEY=your_api_key
   X_API_SECRET=your_api_secret
   X_ACCESS_TOKEN=your_access_token
   X_ACCESS_TOKEN_SECRET=your_access_token_secret
   ```

## Using with Claude Desktop

To connect this Twitter MCP server to Claude Desktop:

1. **Open Claude Desktop Settings:**
   - Open the Claude Desktop application
   - Click the Claude menu from the top of your screen
   - Select "Settings..."

2. **Open Developer Settings:**
   - Select the "Developer" tab in the left panel
   - Click "Edit Config." This should open a `claude_desktop_config.json` file in your text editor

3. **Add the Server Configuration:**
   Add the following configuration to your `claude_desktop_config.json`:

   ```json
   {
     "mcpServers": {
       "twitter": {
         "command": "node",
         "args": [
           "/ABSOLUTE/PATH/TO/node_modules/mcp-twitter-server/dist/index.js"
         ],
         "env": {
           "X_API_KEY": "YOUR_TWITTER_API_KEY",
           "X_API_SECRET": "YOUR_TWITTER_API_SECRET",
           "X_ACCESS_TOKEN": "YOUR_TWITTER_ACCESS_TOKEN",
           "X_ACCESS_TOKEN_SECRET": "YOUR_TWITTER_ACCESS_TOKEN_SECRET"
         }
       }
     }
   }
   ```

   Replace the placeholders:
   - Update the path to match your project's `node_modules` location
   - Add your actual Twitter API credentials
   - **macOS path example:** `/Users/yourusername/project/node_modules/mcp-twitter-server/dist/index.js`
   - **Windows path example:** `C:\\Users\\yourusername\\project\\node_modules\\mcp-twitter-server\\dist\\index.js`

4. **Save and Restart:**
   - Save the `claude_desktop_config.json` file
   - Restart Claude Desktop

## Available Tools

### postTweet
Posts a new tweet to Twitter.
```typescript
{
    text: string; // The text of the tweet
}
```

### searchTweets
Searches for tweets on Twitter.
```typescript
{
    query: string; // The search query
}
```

### replyToTweet
Replies to an existing tweet.
```typescript
{
    tweetId: string; // The ID of the tweet to reply to
    text: string;    // The text of the reply
}
```

## Current Status

Based on extensive testing, here is the current status of all Twitter API tools:

### Working as Expected (17 tools):
1. getUserInfo - Get user profile information
2. getUserTimeline - Retrieve user's tweets
3. postTweet - Post new tweets
4. getTweetById - Fetch specific tweet
5. likeTweet - Like a tweet
6. replyToTweet - Reply to tweets
7. searchTweets - Search for tweets
8. unlikeTweet - Remove like from tweet
9. retweet - Retweet content
10. undoRetweet - Remove retweet
11. followUser - Follow a user
12. unfollowUser - Unfollow a user
13. createList - Create new lists
14. addUserToList - Add members to lists
15. removeUserFromList - Remove list members
16. getListMembers - View list membership
17. getUserLists - Get user's lists

### Working Differently Than Expected (2 tools):
1. getLikedTweets - Returns empty results even when likes exist
2. getRetweets - Returns empty results even for known retweets

### Not Working (4 tools):
1. getFollowers - Returns 403 error
2. getFollowing - Returns 403 error
3. getHashtagAnalytics - Returns 400 error
4. postTweetWithMedia - Not implemented (requires media file upload capabilities)

### Notable Observations:
- List operations provide detailed information and work reliably
- User management operations (follow/unfollow) function smoothly
- Tweet interactions (like, unlike, retweet, unretweet) are consistent
- Some endpoints may have rate limiting or authentication restrictions (403 errors)
- Hashtag analytics feature requires additional implementation work

## Using the Tools

Once connected, you can use the tools by prompting Claude. For example:

1. **Post a tweet:**
   ```
   Post a tweet saying "Hello, world!"
   ```

2. **Search for tweets:**
   ```
   Search for tweets about "artificial intelligence"
   ```

3. **Reply to a tweet:**
   ```
   Search for tweets about "test"
   ```
   Then use the tweet ID from the results:
   ```
   Reply to tweet with id <TWEET_ID> saying "This is a reply"
   ```

## Development

To run the server directly:

1. Clone the repository:
   ```bash
   git clone https://github.com/crazyrabbitLTC/mcp-twitter-server.git
   cd mcp-twitter-server
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Build and run:
   ```bash
   npm run build
   npm start
   ```

## Contributing

Contributions are welcome! Please feel free to submit pull requests or create issues to suggest improvements.

## License

This project is licensed under the MIT License.
```

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
